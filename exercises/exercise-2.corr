// Implement a `map` function that takes a function and a list, and applies the function to each element of the list,
// returning a new list with the transformed values.
// As functions do not support multiple arguments directly, use currying.

let input1: List Int = [1, 2, 3, 4, 5];
let input2: List Int = [];

fn map(f) {
    fn(lst: List Int) {
        if lst == [] {
            []
        } else {
            let first: Int = head(lst);
            let rest: List Int = tail(lst);
            let mapped_first: Int = f(first);
            let mapped_rest: List Int = map(f)(rest);
            cons(mapped_first, mapped_rest)
        }
    }
}

fn increment(x: Int) -> Int {
    x + 1
}

fn multiply(x: Int) -> Int {
    x * 10
}


let result = map(increment)(input1);
let result_empty = map(increment)(input2);

let result_multiply = map(multiply)(input1);

print("Mapped result: " + toString(result)); // Expected output: [2, 3, 4, 5, 6]
print("Mapped empty result: " + toString(result_empty)); // Expected output: []
print("Mapped multiply result: " + toString(result_multiply)); // Expected output: [10, 20, 30, 40, 50]